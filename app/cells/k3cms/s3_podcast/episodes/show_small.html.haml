-# Compare: ./app/cells/k3cms/s3_podcast/episodes/show_large.html.haml ./app/cells/k3cms/s3_podcast/episodes/show_small.html.haml

-# This "should" be inside of the .show_small container too. But when it is, it causes the position of the tooltip to be calculated incorrectly since its parent element is positioned relative (due to the expose mask).
- if can?(:edit, @episode) && edit_mode?
  .context_ribbon{:id => dom_id(@episode)}
    .code
      %label Code:
      - if true
        = inline_editable('span', @episode, :code) do
          = @episode.code
      - if false
        = best_in_place @episode, :code, :type => :input

%div{:class => k3cms_s3_podcast_episode_classes(@episode) + ['show_small'], :id => dom_id(@episode)}
  .thumbnail
    - if can?(:edit, @episode) && edit_mode?
      = k3cms_s3_podcast_episode_thumbnail_image_url(@episode)
    - else
      = link_to k3cms_s3_podcast_episode_thumbnail_image_url(@episode), @episode

  %h3.title
    - if can?(:edit, @episode) && edit_mode?
      = inline_editable('span', @episode, :title) do
        = raw @episode.title
    - else
      = link_to raw(@episode.title), k3cms_s3_podcast_episode_path(@episode)

  = render_cell('k3cms/s3_podcast/episodes', :published_status, :episode => @episode)

  .published_at
    %label Date:
    - if can?(:edit, @episode) && edit_mode?
      = inline_editable('span', @episode, :published_at) do
        = raw @episode.published_at
    - else
      = @episode.published_at && @episode.published_at.to_s(:long)

  .description
    - if can?(:edit, @episode) && edit_mode?
      = inline_editable('div', @episode, :description) do
        = raw @episode.description
    - else
      = raw @episode.description

  .tags
    %label Tags:
    - if can?(:edit, @episode) && edit_mode?
      = best_in_place @episode, :tag_list, :type => :input
    - else
      = k3cms_s3_podcast_episode_linked_tag_list(@episode)


  - if can?(:edit, @episode) && edit_mode?
    .editor_links
      - if @episode.new_record?
        - js = capture do
          :plain
            K3cms_InlineEditor.saveMultipleElements({
              url: #{polymorphic_url(@episode, :only_path => true).to_json},
              'save-type': 'POST',
              object_name: #{dom_class(@episode).to_json},
              elements: $('#new_k3cms_s3_podcast_episode .editable'),
              save_success: function(data, msg, xhr, options) {
                if (data.error) {
                  return;
                }
                $('#new_k3cms_s3_podcast_episode').data('close_box_when_mask_closes', false);
                $.mask.close();

                // Now that we've created the record, we need to do an Ajax request and actually replace the New Object box with an Update Object box
                // so that we have an object_id and the correct url and save-type for updating, so that inline-editing will work.
                // We could probably update the existing DOM elements, but this is easier...
                $.get(k3cms_s3_podcast_episode.url_for(options.object.id), {size: 'small'}, function(data) {
                  $('#new_k3cms_s3_podcast_episode').eq(0).replaceWith(data);

                  K3cms_S3Podcast.fix_clears();

                  // Add the #new_k3cms_s3_podcast_episode box back into the DOM (initially hidden) so they can add another New Episode
                  $.get(#{new_k3cms_s3_podcast_episode_path.to_json}, {size: 'small'}, function(data) {
                    $('.k3cms_s3_podcast.episode_list>.k3cms_s3_podcast_episode:visible:eq(0)').before(data);

                    // TODO: instead of having it add editors to *all* the '.editable' elements (some of which have already been initialized for editing),
                    // we should selectively add the inline editor to *only* the elements we just added to the DOM. (Or change initInlineEditor to use livequery or something
                    // so it automatically applies it to .editable elements as soon as they're added to the DOM.
                    K3cms_InlineEditor.initInlineEditor();
                  });
                });
              },
            });
        = button_to_function 'Create', js
        = link_to_function image_tag('k3cms/s3_podcast/cancel.png', :alt => 'Cancel') + ' Cancel', "$(this).closest('.k3cms_s3_podcast_episode').trigger('close')"

      - else
        - if can?(:edit, @episode)
          = link_to image_tag('k3cms/s3_podcast/pencil_go.png', :alt => 'Edit') + ' Edit', polymorphic_url(@episode, :only_path => true)
        - if can?(:destroy, @episode)
          = link_to image_tag('k3cms/s3_podcast/delete.png', :alt => 'Delete')  + ' Delete', polymorphic_url(@episode, :only_path => true), :confirm => 'Are you sure?', :method => :delete, :remote => true


:javascript
  $(function() {
    var this_episode_box = $('.edit_mode_on .k3cms_s3_podcast_episode.show_small##{dom_id(@episode)}}');
    var this_context_ribbon_selector = '.context_ribbon##{dom_id(@episode)}}';

    this_episode_box.bind('close', function() {
      if (!$(this).data('closing')) {
        $.mask.close();
      } else if ($(this).data('closing') === 'expose is closed') {
        $('.k3cms_s3_podcast.episode_list>#new_k3cms_s3_podcast_episode').toggle(); K3cms_S3Podcast.fix_clears();
        $(this).data('closing', false)
      }

      $(this_context_ribbon_selector).hide();
    });

    this_episode_box.tooltip({
      //events: {tooltip: "mouseenter"},
      delay: 100,
      position: 'top left',
      relative: true,
      tip: this_context_ribbon_selector,
      offset: [0, 0], // We don't want any gap or tooltip may disappear while moving mouse up through the gap.
      onBeforeShow: function() {
        var conf = this.getConf();
        this.getTip().css('width', this.getTrigger().innerWidth() + 'px');
        conf.offset[1] = this.getTrigger().outerWidth();
      },
      onShow: function() {
        this.getTrigger().addClass('active');
      },
      onHide: function() {
        this.getTrigger().removeClass('active');
      },
    });
  });

