-# vim: ft=javascript

:javascript
  $(function() {
    var this_episode_box = $('.edit_mode_on .k3cms_s3_podcast_episode##{dom_id(@episode)}');
    var this_context_ribbon_selector = '.k3cms_s3_podcast_episode##{dom_id(@episode)} .context_ribbon';

    this_episode_box.tooltip({
      // By default, the tooltip closes when you mouseenter the tooltip and then mouseleave it. This is a problem (at least with the table view). If they are moving their mouse right back down to the trigger, then the mouseleave from the tooltip should not trigger it to close!
      events: {tooltip: ","},
      delay: 100,
      position: 'top left',
      relative: true,
      tip: this_context_ribbon_selector,
      offset: [-0, -5], // y, x
      onBeforeShow: function() {
        this.getTip().css('min-width', this.getTrigger().innerWidth() + 'px');
      },
      onShow: function() {
        this.getTrigger().addClass('active');
      },
      onBeforeHide: function(event) {
        if (this.getTrigger().hasClass('new_record')) {
          event.preventDefault()
        }
      },
      onHide: function() {
        this.getTrigger().removeClass('active');
      },
    });

    this_episode_box.bind('toggle', function() {
      if ($(this).is(':visible')) {
        $(this).trigger('close')
      } else {
        $(this).trigger('open')
      }
    });

    this_episode_box.bind('open', function() {
      var $this = $(this);
      $this.show();
      K3cms_S3Podcast.update_row_striping();
      K3cms_S3Podcast.fix_clears();

      var tooltip = $this.data('tooltip');
      if (tooltip) {
        tooltip.show(); // There's a bug that makes this not work. isShown() incorrectly returns 'full'.
        tooltip.getTip().show();
      }

      // TODO: fix expose for table/list view. The problem is, it seems, td's can't have a z-index. Possible workaround: divs inside the td can have a z-index. But still didn't seem to be a perfect or easy solution.
      var use_expose_effect = $this.data('use_expose_effect')
      //console.debug("use_expose_effect=", use_expose_effect, use_expose_effect ? 'yes' : 'no', typeof use_expose_effect);
      if (use_expose_effect) $this.expose({
        color:'#000',
        opacity: 0.6,
        onClose: function() {
          var e = this.getExposed()
          //console.debug("e.data('closing')=", e.data('closing'));
          if (!e.data('closing') && $this.data('close_box_when_mask_closes') !== false) {
            e.data('closing', 'expose is closed');
            e.trigger('close');
          }
        },
      });

      // Focus first editable field
      $(this_episode_box.selector + ' .editable[data-attribute=code]').eq(0).focus()
    });

    this_episode_box.bind('close', function() {
      if ($.mask.isLoaded() && !$(this).data('closing')) {
        $.mask.close();
      } else if ($.mask.isLoaded() === undefined || $(this).data('closing') === 'expose is closed') {
        $(this).hide();
        K3cms_S3Podcast.fix_clears();
        $(this).data('closing', false)
      }

      $(this_context_ribbon_selector).hide();
    });

    $("a.lightbox[rel]").overlay({
      mask: '#000',
      onBeforeLoad: function() {
        var wrap = this.getOverlay().find(".content");
        wrap.load(this.getTrigger().attr("href"));
      }
    });

    K3cms_S3Podcast.update_row_striping();

    $(this_episode_box.selector + ' .create_button').click(function() {
      K3cms_InlineEditor.saveMultipleElements({
        url: #{polymorphic_url(@episode, :only_path => true).to_json},
        'save-type': 'POST',
        object_name: #{dom_class(@episode).to_json},
        elements: $('.new_k3cms_s3_podcast_episode .editable, .new_k3cms_s3_podcast_episode input'),
        save_success: function(data, msg, xhr, options) {
          if (data.error) {
            return;
          }

          $('.context_ribbon.new_k3cms_s3_podcast_episode').remove();

          var tooltip = $('#new_k3cms_s3_podcast_episode').data('tooltip');
          tooltip.getTip().hide();

          $('#new_k3cms_s3_podcast_episode').data('close_box_when_mask_closes', false);
          $.mask.close();

          // Now that we've created the record, we need to do an Ajax request and actually replace the New Object box with an Update Object box
          // so that we have an object_id and the correct url and save-type for updating, so that inline-editing will work.
          // We could probably update the existing DOM elements, but this is easier...
          $.get(k3cms_s3_podcast_episode.url_for(options.object), {size: 'small'}, function(data) {
            $('#new_k3cms_s3_podcast_episode').eq(0).replaceWith(data);

            K3cms_S3Podcast.fix_clears();

            // Add the #new_k3cms_s3_podcast_episode box back into the DOM (initially hidden) so they can add another New Episode
            $.get(#{new_k3cms_s3_podcast_podcast_episode_path(@podcast).to_json}, {size: 'small'}, function(data) {
              $('.k3cms_s3_podcast.episode_list .the_list>.k3cms_s3_podcast_episode:visible:eq(0)').before(data);

              // TODO: instead of having it add editors to *all* the '.editable' elements (some of which have already been initialized for editing),
              // we should selectively add the inline editor to *only* the elements we just added to the DOM. (Or change initInlineEditor to use livequery or something
              // so it automatically applies it to .editable elements as soon as they're added to the DOM.
              K3cms_InlineEditor.initInlineEditor();
            });
          });
        },
      });
    }); // $(this_episode_box.selector + ' .create_button').click(function()

  });
